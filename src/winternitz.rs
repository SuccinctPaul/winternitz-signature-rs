//! "A Graduate Course in Applied Cryptography" in chapter 14.3

use crate::transcript::TranscriptHash;
use crate::utils::{bytes_to_bits, checksum};
use rand::Rng;
use std::io::BufRead;
use std::marker::PhantomData;

struct PRGSecretKey {
    k: u32,
    x: Vec<u32>,
}

struct PublicKey {
    y: u32,
}

// generalized Lamport signature system S_L=(G, S, V )
pub struct WinternitzSignature<T: TranscriptHash> {
    d: u8,
    n: u32,
    phantom: PhantomData<T>,
}

impl<T: TranscriptHash> WinternitzSignature<T> {
    pub fn new(d: u8, n: u32) -> Self {
        Self {
            d,
            n,
            phantom: Default::default(),
        }
    }

    // A secret key is n random values x1. . . . . xn ∈ X for some n that will be determined later.
    // The public-key consists of the n hashes yi := f(xi) for i = 1, . . . , n.
    pub fn gen<R: Rng>(&self, rng: &mut R) -> (PRGSecretKey, PublicKey) {
        // PRG secret key:  sk = (k)
        let k = rng.next_u32() % 1000;

        // sk : A secret key is n values x1... xn ∈ X,
        // 1. they can be random ones
        // 2. they can be generated by PRF key as xi ← F(k, i)
        //      and here we define F as power function.
        let x = Self::gen_sk(k, self.n);

        let y = Self::gen_vk(&x, self.d as u32);

        (PRGSecretKey { k, x }, PublicKey { y })
    }
    // 2. they can be generated by PRG key as xi ← F(k, i)
    //      and here we define F as power function.
    pub fn gen_sk(k: u32, n: u32) -> Vec<u32> {
        // let a = 755285067_u32 * 12;
        (0..n).into_iter().map(|i| k * i).collect::<Vec<_>>()
    }

    pub fn gen_vk(x: &Vec<u32>, d: u32) -> u32 {
        // yi := f^d (xi)
        //      f is a one-way hash
        let y_vec = x
            .iter()
            .map(|v| Self::hash_chain(*v, d))
            .collect::<Vec<_>>();
        // pk :  Hash(y1,...,yi)
        T::hash_vec_to_u32(y_vec)
    }

    // sign a v-bit message
    pub fn sign(&self, sk: &PRGSecretKey, msg: &Vec<u8>) -> Vec<u32> {
        let k = sk.k;
        let x = &sk.x;

        // m': maps m to a subset of {1, ... , n} using a special function P
        //  A subset s ← P(m) ⊆ {1, . . . , n}
        let s = self.P_m(msg.clone());

        // proof = f^si (xi)
        //      which use the same method with gen_vk
        x.into_iter()
            .zip(s)
            .map(|(xi, s_i)| Self::hash_chain(*xi, s_i as u32))
            .collect()
    }

    // TO reform the msg into n len.
    pub fn P_m(&self, msg: Vec<u8>) -> Vec<u8> {
        let padding_msg = if self.n as usize > msg.len() {
            let diff = self.n as usize - msg.len();
            let mut padding = vec![];
            padding.extend(msg);
            for (i, di) in (0..diff).into_iter().enumerate() {
                if i % 2 == 0 {
                    padding.push(0);
                } else {
                    padding.push(1);
                }
            }
            padding
        } else if (self.n as usize) < msg.len() {
            msg.as_slice()[0..(self.n as usize)].to_vec()
        } else {
            msg
        };

        padding_msg.iter().map(|pi| pi % self.d).collect::<Vec<_>>()
    }

    // To verify a signature σ on m simply check that f(σ) = y_m. We call this system S1bit.
    fn verify(&self, pk: &PublicKey, msg: &Vec<u8>, sig: Vec<u32>) -> bool {
        let s = self.P_m(msg.clone());
        // proof = f^si (xi)
        //      which use the same method with gen_vk
        let y_peek = sig
            .into_iter()
            .zip(s)
            .map(|(o_i, s_i)| Self::hash_chain(o_i, (self.d - s_i) as u32))
            .collect();
        let actual = T::hash_vec_to_u32(y_peek);

        actual == pk.y
    }

    pub fn hash_chain(input: u32, iter_num: u32) -> u32 {
        let mut v = input;
        for i in 0..iter_num {
            v = T::hash_to_u32(v);
        }
        v
    }
}

#[cfg(test)]
mod test {
    use super::*;
    use crate::transcript::{Blake3TranscriptHash, Keccak256TranscriptHash};
    use crate::winternitz;
    use rand::{RngCore, SeedableRng};
    use rand_chacha::ChaCha20Rng;

    #[test]
    fn test_basiclamport_signature() {
        let msg = b"hello, here is the test for witnernitz signature".to_vec();

        let d = 3;
        let n = 29;

        let winternitz = WinternitzSignature::<Blake3TranscriptHash>::new(d, n);

        let mut prng = ChaCha20Rng::seed_from_u64(733);

        let (sk, pk) = winternitz.gen(&mut prng);
        let sig = winternitz.sign(&sk, &msg);
        assert!(
            winternitz.verify(&pk, &msg, sig),
            "WinternitzSignature::<Blake3TranscriptHash> verify failed when m=1"
        );

        let winternitz = WinternitzSignature::<Keccak256TranscriptHash>::new(d, n);
        let (sk, pk) = winternitz.gen(&mut prng);
        let sig = winternitz.sign(&sk, &msg);
        assert!(
            winternitz.verify(&pk, &msg, sig),
            "WinternitzSignature::<Keccak256TranscriptHash> verify failed when m=1"
        );
    }
}
