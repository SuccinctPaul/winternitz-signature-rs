//! "A Graduate Course in Applied Cryptography" in chapter 14.2

mod basic_lamport_signature;
mod one_bit_lamport;

use crate::transcript::TranscriptHash;
use crate::utils::{bytes_to_bits, checksum};
use rand::Rng;
use std::marker::PhantomData;

struct PRFSecretKey {
    k: u32,
}

struct SecretKey {
    x: Vec<u32>,
}

struct PublicKey {
    y: Vec<u32>,
}

impl SecretKey {
    // 2. they can be generated by PRF key as xi ← F(k, i)
    //      and here we define F as power function.
    pub fn secret_key_from_a(k: u32, n: u32) -> Vec<u32> {
        (0..n).into_iter().map(|i| F(k, i)).collect::<Vec<_>>()
    }
}

// generalized Lamport signature system S_L=(G, S, V )
pub struct LamportSignatureFramework<T: TranscriptHash> {
    bit_len: usize,
    phantom: PhantomData<T>,
}

impl<T: TranscriptHash> LamportSignatureFramework<T> {
    // A secret key is n random values x1, . . . , xn ∈ X for some n that will be determined later.
    // The public-key consists of the n hashes yi := f(xi) for i = 1, . . . , n.
    pub fn gen<R: Rng>(rng: &mut R, n: u32) -> (PRFSecretKey, PublicKey) {
        // PRF secret key:  sk = (k)
        let k = rng.next_u32() % 10000;

        // sk : A secret key is n values x1, . . . , xn ∈ X,
        // 1. they can be random ones
        // 2. they can be generated by PRF key as xi ← F(k, i)
        //      and here we define F as power function.
        let x = SecretKey::secret_key_from_a(k, n);

        // pk :  yi := f(xi)
        //      f is a one-way hash
        let y = x.iter().map(|v| T::hash_to_u32(*v)).collect::<Vec<_>>();

        (PRFSecretKey { k }, PublicKey { y })
    }

    // sign a v-bit message
    pub fn sign(sk: &PRFSecretKey, msg: &[u8]) -> Vec<u32> {
        let k = sk.k;
        let v = msg.len() * 8;
        let n = n(v);

        let msg_bits = bytes_to_bits(msg);
        assert_eq!(msg_bits.len(), v);

        // m': maps m to a subset of {1, . . . , n} using a special function P
        //  A subset s ← P(m) ⊆ {1, . . . , n}
        let s = p_opt(&msg_bits);
        assert_eq!(s.len(), n);

        // S(sk, m) := x_m.
        // TODO: todo F.
        s.into_iter()
            .enumerate()
            .map(|(j, s_j)| F(k, s_j))
            .collect()
    }

    // To verify a signature σ on m simply check that f(σ) = y_m. We call this system S1bit.
    fn verify(pk: &PublicKey, msg: &[u8], sig: Vec<u32>) -> bool {
        assert_eq!(
            msg.len() * 8,
            sig.len(),
            "msg bit len should be equal with sig ones"
        );
        assert_eq!(
            pk.y.len(),
            sig.len(),
            "pk.y len should be equal with sig ones"
        );

        let v = msg.len() * 8;
        let n = n(v);

        let msg_bits = bytes_to_bits(msg);
        assert_eq!(msg_bits.len(), v);

        // m': maps m to a subset of {1, . . . , n} using a special function P
        //  A subset s ← P(m) ⊆ {1, . . . , n}
        let s = p_opt(&msg_bits);
        assert_eq!(s.len(), n);

        for ((i, &si), f_tau) in s.iter().enumerate().zip(sig) {
            let y_m = pk.y[si as usize];

            if T::hash_to_u32(f_tau) != y_m {
                return false;
            }
        }
        true
    }
}

// A secure PRF defined over (K, {1, . . . , n}, X ).
// xi ← F(k, i)
fn F(k: u32, i: u32) -> u32 {
    k * i
}

// 14.2.1 An explicit containment free function
// Containment free functions are easy to build: take P to be an injective function that always
// outputs subsets of a fixed size l.
//
// input: m ∈ {0, 1}^v
// output: Popt(m) ⊆ {1, . . . , n}
// TODO: needs debug
fn p_opt(m: &Vec<bool>) -> Vec<u32> {
    let v = m.len();
    let log2_v_plus_1 = ((v as f32).log2().ceil() as usize) + 1;
    let n = n(v);

    // c ∈ [0, v] is the number of 0s in m
    let c = v - wight_of_msg(m);

    // encode c as a binary, c is called a checksum
    let c_bits = checksum(c as u32, log2_v_plus_1);

    // m' = m || c_bits
    let m_apostrophe = vec![m.to_vec(), c_bits].concat();

    // set {i s.t. mi' = 1} ⊆ {1, . . . , n}
    // TODO: needs debug here.
    m_apostrophe
        .iter()
        .enumerate()
        .map(|(i, &mi)| if mi { i as u32 } else { 0 })
        .collect::<Vec<_>>()
}

fn n(v: usize) -> usize {
    // n := v + 1 + (log2 v).ceil
    v + 1 + ((v as f32).log2().ceil() as usize)
}

// weight of a bit string m ∈ {0, 1}^v is the number of bits in m that are set to 1
fn wight_of_msg(m: &Vec<bool>) -> usize {
    m.iter().filter(|&x| *x == true).count()
}

#[cfg(test)]
mod test {
    use super::*;
    use crate::transcript::{Blake3TranscriptHash, Keccak256TranscriptHash};
    use rand::{RngCore, SeedableRng};
    use rand_chacha::ChaCha20Rng;

    #[test]
    fn test_basiclamport_signature() {
        let mut prng = ChaCha20Rng::seed_from_u64(7987979837453);
        let msg = b"hello, here is the test for basic Lamport signature";
        let msg_len = msg.len() * 8;
        let n = n(msg_len) as u32;

        let (sk, pk) = LamportSignatureFramework::<Blake3TranscriptHash>::gen(&mut prng, n);
        let sig = LamportSignatureFramework::<Blake3TranscriptHash>::sign(&sk, msg);
        assert!(
            LamportSignatureFramework::<Blake3TranscriptHash>::verify(&pk, msg, sig),
            "LamportSignatureFramework::<Blake3TranscriptHash> verify failed when m=1"
        );

        let (sk, pk) = LamportSignatureFramework::<Keccak256TranscriptHash>::gen(&mut prng, n);
        let sig = LamportSignatureFramework::<Keccak256TranscriptHash>::sign(&sk, msg);
        assert!(
            LamportSignatureFramework::<Keccak256TranscriptHash>::verify(&pk, msg, sig),
            "LamportSignatureFramework::<Blake3TranscriptHash> verify failed when m=1"
        );
    }
}
